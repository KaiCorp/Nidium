#!/usr/bin/env python2.7

# Copyright 2016 Nidium Inc. All rights reserved.
# Use of this source code is governed by a MIT license
# that can be found in the LICENSE file.

import sys
import os
import json

from konstructor import Deps
from konstructor import CommandLine
from konstructor import Build
from konstructor import Builder
from konstructor import Platform
from konstructor import Konstruct
from konstructor import Utils
from konstructor import Variables
from konstructor import Tests
from konstructor import PackageManger
from konstructor import Log
from konstructor import ROOT

Gyp = Builder.Gyp

Deps.set(
    "giflib",
    "libzip",
    "breakpad",
    "basekit",
    "libcoroutine",
    "SDL2",
    "rapidxml",
    "depot_tools",
    "angle",
    "skia",
    Deps.Konstruct("libnidiumcore", "configure_libnidiumcore")
)

if Platform.system == "Linux":
    Deps.set("libnotify", "lss")
elif Platform.system == "Darwin":
    Deps.set("libnotify")
    Platform.setEnviron("MACOSX_DEPLOYMENT_TARGET=10.7")
elif Platform.system == "Windows":
    Deps.set("pthreads4w", "opengl")
    if Platform.wordSize == 32:
        Deps.set("ninja")
    Platform.setEnviron("DEPOT_TOOLS_WIN_TOOLCHAIN=0")
    Platform.setCompiler("cl", 'cl')
    Platform.setEnviron("LD=Link")
    Platform.setEnviron("AR=lib")

Gyp.setArgs("--depth ./ --include=gyp/config.gypi --include=gyp/common.gypi")
Gyp.set("nidium_product_define", "NIDIUM_PRODUCT_FRONTEND")
Gyp.set("nidium_js_disable_window_global", 0)
Gyp.set("nidium_audio", 0)

if Builder.Gyp.get("nidium_audio", True):
    Deps.set(
        "portaudio",
        "zita-resampler",
        "ffmpeg",
    )

DEPEDENCY_REPO = Variables.get("depsRepo")
CONFIGURE_PATH = os.path.dirname(os.path.realpath(__file__))

@Deps.register("portaudio")
def portaudio():
    no_backend = ['jack', 'asihpi', 'winapi']
    do_backend = []
    if Platform.system == "Windows":
        Platform.setCompiler("cl", 'cl')
        Platform.setEnviron('LD=link')
        cmake, platform, toolset = Platform.CMake()
        build = [cmake + " -DPA_UNICODE_BUILD=1 -DPA_USE_WASAPI=0 -DPA_USE_WDMKS=0 -DPA_USE_WMME=1",
                Platform.MsBuild("portaudio_static.vcxproj")]
        output = "./Release/portaudio_static_x86.lib"
        patch = []
    else:
        configure = "./configure"
        for backend in no_backend:
            configure += " --without-%s" % (backend)
        for backend in do_backend:
            configure += " --with-%s" % (backend)
        configure += " --disable-debug-output --enable-static --disable-shared"
        build = [configure, "make -j1", "make  src/common/pa_ringbuffer.o"]
        output = "lib/.libs/libportaudio.a"
        patch = [os.path.join(CONFIGURE_PATH, "patch", "portaudio.patch")]
    return {
        "location": DEPEDENCY_REPO + "/portaudio.tgz",
        "build":  build,
        "outputs": [output],
        "patchs" : patch
    }

@Deps.register("zita-resampler")
def zitaresampler():
    cxx_flags = "CXXFLAGS=-D_USE_MATH_DEFINES"
    if Platform.system == "Windows":
        cxx_flags += " -I ../../pthreads4w -D_POSIX_C_SOURCE=200112L "
    Platform.setEnviron(cxx_flags)
    return {
        "location": DEPEDENCY_REPO + "/zita-resampler-1.3.0.tar.bz2",
        "patchs": [os.path.join(CONFIGURE_PATH, "patch", "zita-resampler.patch")],
        "chdir": "libs/",
        "build": ["make"],
        "outputs": ["libzita-resampler(.a|.lib)"]
    }

@Deps.register("giflib")
def giflib():
    location = "http://downloads.sourceforge.net/project/giflib/giflib-4.x/giflib-4.2.3.tar.gz"
    if Platform.system == "Windows":
        Platform.setCompiler("cl", 'cl')
        Platform.setEnviron("LD=link")
        Platform.setEnviron("AR=lib")
        return {
            "location": location,
            "build": ["bash ../configure --disable-shared --enable-static",
                      'sed -i.bak -e "s/AR_FLAGS /AR_FLAGS/" libtool',
                      "make -j1"],
            "chdir": "lib",
            "patchs": [os.path.join(CONFIGURE_PATH, "patch", "giflib_windows.patch")],
            "outputs": ["../lib/.libs/gif.lib"]
        }

    else:
        # skdiff is used during unit-tests and it needs libgif.so.4
        Platform.setEnviron("LD_LIBRARY_PATH=$LD_LIBRARY_PATH:%s/giflib/lib/.libs/" % os.getcwd())
        return {
            "location": location,
            "build": ["./configure", "make"],
            "outputs": ["lib/.libs/libgif.a"]
        }

@Deps.register("skia")
def skia():
    pref = "lib"
    ext = ".a"
    if Platform.system == "Windows":
        pref = ""
        ext = ".lib"
        import stat
        cpu = ["x86", "x64"][Platform.wordSize == 64]
        args = {
            "is_official_build": True,
            "target_cpu":cpu,
            "cc": Platform.getEnviron("CC"),
            "cxx": Platform.getEnviron("CXX")
        }
        toolset = Platform.MSVC.toolset(Variables.get('msvs_version', 2015))
        skiaArgs = ['%s=%s' % (k, json.dumps(v)) for k, v in args.items()]
        #gn has a realy frustrating quoting argument policy
        gn_string = """gn gen out/Static --ide='vs' '--args=%s\'""" % (" ".join(skiaArgs))
        gn_hack = "../nidium_gn_quote.sh"
        file_h = open("skia/" + gn_hack, 'w')
        dir = "/c/data/nidium/Nidium/third-party/"
        file_h.write("#!/bin/bash\n\n" +
                   "export PATH=%s/depot_tools/python276_bin:%s/depot_tools/python:%s/angle/buildtools/win" % (dir, dir, dir) +
                 "\n\n" +
                gn_string )
        file_h.close()
        st = os.stat("skia/" + gn_hack)
        os.chmod("skia/" + gn_hack, st.st_mode | stat.S_IEXEC)
        build = [ #"python tools/git-sync-deps",
                  #"bash ./%s||true" % (gn_hack),
                  #"python gn/gn_meta_sln.py",
                  #Platform.MsBuild("out/sln/skia.sln", None, None, None)]
                ]
    else:
        args = {
            "extra_cflags_cc": [
                "-Wno-unused-function",
                "-Wno-array-bounds",
                "-Wno-return-local-addr",
                "-DGR_GL_CUSTOM_SETUP_HEADER=<../../../../../patch/skia_gl_config.h>"
                ],
            "is_official_build": True,
            "cc": Platform.getEnviron("CC"),
            "cxx": Platform.getEnviron("CXX")
        }

    if Platform.system == "Darwin":
        args["extra_cflags_cc"].append("-stdlib=libc++")
        args["extra_ldflags"] = ["-stdlib=libc++"]
    skiaArgs = ''
    for k, v in args.items():
        #skiaArgs += r' %s="%s"' % (k, json.dumps(v))
        skiaArgs += " %s=%s" % (k, json.dumps(v))
    build = [ "python tools/git-sync-deps",
               """./bin/gn gen out/Static '--args=%s' """ % (skiaArgs),
             "ninja %s -C out/Static" % ("-v" if Variables.get("verbose") else "")]
    # Add depot_tools to path needed for skia
    Platform.setEnviron("PATH+=" + os.path.join(Deps.getDir(), "depot_tools"))

    # depot_tools and skia needs python2.7 but use "python" as the default
    # interpreter which could be python3.x on some system. Workaround that
    # by using a custom python wrapper that will redirect to the correct python version
    Platform.setEnviron("PATH=" + os.path.join(ROOT, "tools") + ":" + os.environ.get("PATH", ""))

    return {
        "location": Deps.GitRepo("https://skia.googlesource.com/skia.git", revision="98829b9"),
        "build": build,
        "patchs": [
            os.path.join(CONFIGURE_PATH, "patch", "skia_gl.patch"),
            os.path.join(CONFIGURE_PATH, "patch", "skia_gr_gl_callback.patch")
        ],
        "outputs": [
            "out/Static/%sskia%s" % (pref, ext),
            {
                "src": "out/Static/skdiff",
                "dst": os.path.join(ROOT, "tests", "jsunittest", "gr", "skdiff")
            }
        ]
    }

@Deps.register("libzip")
def libzip():
    Platform.setEnviron('CMAKE_AR=lib')
    if Platform.system == "Windows":
        output = "./lib/Release/zip.lib"
        cmake, platform, toolset = Platform.CMake()
        build = [cmake + " -DZLIB_LIBRARY=%s/zlib/zlib.lib -DZLIB_INCLUDE_DIR=%s/zlib" % (Deps.getDir(), Deps.getDir()),
                Platform.MsBuild("libzip.sln")]
    else:
        output = "lib/.libs/libzip.a"
        build = ["autoreconf -fi",
                 "./configure  --disable-shared --with-zlib=%s/zlib/" % (Deps.getDir()), "make"]
    return {
        #todo figure out how to get commit of 'today'
        "location": "http://hg.nih.at/libzip/archive/tip.zip",
        "build": build,
        "patchs": [os.path.join(CONFIGURE_PATH, "patch", "libzip.patch")],
        "outputs": [output]
    }

@Deps.register("lss")
def lss():
    if Platform.system == "Windows":
        Log.error("The '%s' platform does not need lss" % (Platform.system))
        sys.exit(1)
    return {
        "location": Deps.GitRepo("https://chromium.googlesource.com/linux-syscall-support", revision="348bdf8d32b37c8fb2627df7a0a977d1d640e1fc")
    }

def fixAngleThinArchive():
    # By default ANGLE libs are thin archive, and thus, not relocatable
    # which breaks Konstructor way of dealing with archives. We need to
    # update ninja build file, to create "normal" archive
    if Platform.system == "Linux" or Platform.system == "Darwin":
        Utils.run("sed -i.bak \"s/$ar rcsT/$ar rcs/\" out/Release/build.ninja")

@Deps.register("angle")
def angle():
    outputs = ["preprocessor", "translator", "angle_common"]
    if Platform.system == "Windows":
        pref = ''
        ext = '.lib'
        Platform.setEnviron("CXXFLAGS=-MD")
        Platform.setEnviron("CFLAGS=-MD")
        patch = [os.path.join(CONFIGURE_PATH, "patch", "angle_windows.patch")]
        location =  Deps.GitRepo("https://github.com/Microsoft/angle.git", revision="f1706c4")
        anglePath = os.path.join(CONFIGURE_PATH, "third-party/angle")
        platform = ["Win32", "x64"][Platform.wordSize == 64]
        outPath = "src/Release_%s/lib/" % (platform)
        Platform.setEnviron('AngleRootPath=%s' % (anglePath))
        build = [Platform.MsBuild("%s/src/angle.sln" % anglePath, options="/p:NODEFAULTLIB=ucrt.lib /p:NODEFAULTLIB=libcpmt.lib")]
        outputs = outputs + [ 'angle_image_util', 'libANGLE', 'libEGL', 'libGLESv2' ]
    else:
        pref = 'lib'
        ext = '.a'
        patch = []
        location =  Deps.GitRepo("https://chromium.googlesource.com/angle/angle", branch="chromium/2785")
        cxxFlags = os.environ.get("CXXFLAGS", "")
        cxxFlags += " -Wno-c++11-narrowing -Wno-sign-compare -Wno-error"
        if Platform.wordSize == 32:
            cxxFlags += " -msse -msse2 -msse3"
        if Platform.system == "Darwin":
            outPath = "out/Release/"
        elif Platform.system == "Linux":
            outPath = "out/Release/obj/src/"
        build = [ "python scripts/bootstrap.py",
                'GYP_GENERATORS=ninja LDFLAGS="%s" CXXFLAGS="%s"' % (os.environ.get("LDFLAGS", ""), cxxFlags) +  " gclient sync",
                fixAngleThinArchive,
                "ninja -C out/Release/"]
        outputs.append("translator_lib")
    return {
        "location": location,
        "build": build,
        "patchs" : patch,
        "outputs": [os.path.join(outPath, pref + i) + ext for i in outputs]
    }

@Deps.register("breakpad")
def breakpad():
    return {
        "location": Deps.GitRepo("https://chromium.googlesource.com/breakpad/breakpad", revision="48b9a40539689743bacbe20df01182b0c367c2c0")
    }

@Deps.register("SDL2")
def SDL2():
    # SDL2 Build as framework
    #build: ["xcodebuild -configuration 'Release' CONFIGURATION_BUILD_DIR='out' -target 'Framework'"],
    #outputs["SDL2/Xcode/SDL/out/SDL2.framework"])
    if Platform.system == "Windows":
        build = [Platform.MsBuild("../VisualC/SDL_VS2013.sln")]
        patchs = [os.path.join(CONFIGURE_PATH, "patch", "SDL2_windows.patch")]
        platform = ["Win32", "x64"][Platform.wordSize == 64]
        outputs = ["../VisualC/SDL/%s/Release/SDL2.lib" % (platform)]
    else:
        build = ["../configure", "make"]
        patchs = []
        outputs = ["build/.libs/libSDL2.a"]
    return {
        "location": "https://www.libsdl.org/release/SDL2-2.0.3.tar.gz",
        "chdir": "build",
        "patchs": patchs,
        "build": build,
        "outputs": outputs
    }

@Deps.register("opengl")
def opengl():
        return {'location' : Deps.GitRepo("https://github.com/KhronosGroup/OpenGL-Registry.git", revision="f1ca0f3")}

@Deps.register("depot_tools")
def depotTools():
    Deps.Gclient.setExec(os.path.join("depot_tools", "gclient"))
    if Platform.system == "Windows":
        ddict = { 'location' : "https://storage.googleapis.com/chrome-infra/depot_tools.zip"}
        if Platform.wordSize == 32:
            ddict['build'] = ['cp ../ninja/ninja.exe ../depot_tools/' ]
    else:
        ddict = {'location' : Deps.GitRepo("https://chromium.googlesource.com/chromium/tools/depot_tools.git", revision="8bf327c")}
    return ddict

@Deps.register("basekit")
def basekit():
    if Platform.system == "Windows":
        Platform.setEnviron('SYS=Windows')
        Platform.setEnviron('INSTALL_PREFIX=%s' % (os.path.join(CONFIGURE_PATH,
        "third-party/basekit/install")))
        patch = [os.path.join(CONFIGURE_PATH, "patch", "basekit_windows.patch")]
        build = ['mkdir "_build/objs" "_build/lib"||true',
                 "make -j1  _build/lib/libbasekit.a PLATFORM=%s" % (["x86","x64"][Platform.wordSize == 64])]
    else:
        patch = [os.path.join(CONFIGURE_PATH, "patch", "basekit.patch")]
        build = ["make"]
    return {
        "location": Deps.GitRepo("https://github.com/stevedekorte/basekit.git", revision="a3e54ba83b85f530dc9442a33d2779240ed96189"),
        "build": build,
        "patchs": patch,
        "outputs": ["_build/lib/libbasekit(.a|.lib)"]
    }

@Deps.register("libcoroutine")
def libcoro():
    if Platform.system == "Windows":
        Platform.setEnviron('SYS=Windows')
        build = ['mkdir "_build/objs" "_build/lib"||true', "make -j1 _build/objs _build/lib/liblibcoroutine.a"]
        patchs = [os.path.join(CONFIGURE_PATH, "patch", "libcoroutine_windows.patch")]
    else:
        build = ["make"]
        patchs = [os.path.join(CONFIGURE_PATH, "patch", "libcoroutine.patch")]
        if Konstruct.config("valgrind"):
            patchs.append(os.path.join(CONFIGURE_PATH, "patch", "libcoroutine.debug.patch"))

    return {
        "location": Deps.GitRepo("https://github.com/stevedekorte/coroutine.git", revision="b0bf11d8a0ec70bc0f1f5043513d334e1eff15fc"),
        "patchs": patchs,
        "build": build,
        "outputs": [["_build/lib/liblibcoroutine(.a|.lib)", "libcoroutine\\1"]]
    }

@Deps.register("rapidxml")
def rapidxml():
    return {
        "location": "http://downloads.sourceforge.net/project/rapidxml/rapidxml/rapidxml%201.13/rapidxml-1.13.zip",
        "patchs": [  os.path.join(CONFIGURE_PATH, "patch", "rapidxml.patch")],
    }

@Deps.register("ffmpeg")
def ffmpeg():
    outputs = [
        "libavcodec/libavcodec(.a|.lib)",
        "libswresample/libswresample(.a|.lib)",
        "libavutil/libavutil(.a|.lib)",
        "libavformat/libavformat(.a|.lib)",
    ]
    make_opt = ''
    #ffmpeg 3.0.7 has a problem on windows where an pathname gets in the $(OBJ) list, lib.exe is more sensitive than ar
    if Platform.system == "Windows":
        configure = "bash configure --toolchain=msvc --extra-cxxflags=\"-MD\" --extra-cflags=\"-MD\" --extra-ldflags=\"/nodefaultlib:libcmt.lib\" --disable-swscale"
        patchs = [  os.path.join(CONFIGURE_PATH, "patch", "ffmpeg_windows.patch")]
        patchs = []
        make_opt += " -j1"
    else:
        outputs.append("libswscale/libswscale(.a|.lib)")
        configure = "./configure"
        patchs = []
    return {
        "location": Deps.GitRepo("git://git.ffmpeg.org/ffmpeg.git", tag="n3.0.7"),
        "patchs": patchs,
        "build":
        [
            configure + " \
           --disable-vaapi --disable-avdevice --disable-postproc --disable-avfilter --disable-ffserver --disable-lzma --disable-bzlib \
            --enable-decoder=ac3,aac,mp3,vorbis,pcm_s16be_planar,pcm_s16le,pcm_s16le_planar,pcm_s24be,pcm_s24daud,pcm_s24le,pcm_s24le_planar,pcm_s32be,pcm_s32le,pcm_s32le_planar,pcm_s8,pcm_s8_planar,pcm_u16be,pcm_u16le,pcm_u24be,pcm_u24le,pcm_u32be,pcm_u32le,pcm_u8,h264,mpeg4,mpeg2video,wmv1,wmv2,wmv3,wmv3_crystalhd,wmv3_vdpau,wmv3image,wmalossless,wmapro,wmav1,wmav2,wmavoice,vc1,vc1_crystalhd,vc1_vdpau,vc1image\
            --enable-parser=vorbis,mpegaudio,mpegvideo,mpeg4video,h264,vp8,aac,vc1\
            --enable-demuxer=matroska,mp3,ogg,vorbis,pcm_alaw,pcm_f32be,pcm_f32le,pcm_f64be,pcm_f64le,pcm_mulaw,pcm_s16be,pcm_s16le,pcm_s24be,pcm_s24le,pcm_s32be,pcm_s32le,pcm_s8,pcm_u16be,pcm_u16le,pcm_u24be,pcm_u24le,pcm_u32be,pcm_u32le,pcm_u8,h264,mpegvideo,aac,mov,avi,wav,asf\
            --enable-stripping --enable-static --disable-shared",
            "make" + make_opt
        ],
        "outputs": outputs
    }

@Deps.register("libnotify")
def libnotify():
    return {
        "location": DEPEDENCY_REPO + "/libnotify-0.7.6.tar.gz",
        "build": ["./configure", "make"],
        "outputs": ["libnotify/.libs/libnotify.a"]
    }


def getNidiumPath():
    nidium = ""
    if Platform.system == "Linux":
        return ("bin/", "./nidium")
    elif Platform.system == "Darwin":
        return ("bin/", "./nidium.app/Contents/MacOS/nidium")
    else:
        raise Exception("TODO : Unsupported platform, cannot find nidum executable")

def addEmbed():
    # Build dir2nvfs
    if not os.path.exists("tools/dir2nvfs"):
        Gyp("gyp/tools.gyp", defines={"nidium_js_disable_window_global": 1,
                                      "nidium_product_define": "DIR2NVFS"}).run("dir2nvfs")

    # Generate the embed file with dir2nvfs
    Gyp("gyp/actions.gyp").run("generate-embed", parallel=False)

    # Now that the embed are packaged
    # we can add add nidium_package_embed flag
    Gyp.set("nidium_package_embed", 1)

@CommandLine.option("--embed", default=False)
def embed(embed):
    if embed:
        @Konstruct.hook("preBuild")
        def preBuildAddEmbed():
            addEmbed()

@CommandLine.option("--auto-tests", default=False)
def autoTestStudio(autoTests):
    if not autoTests:
        return

    tests = []
    nidium = getNidiumPath()

    # Find Konstrutor path, to run Dokumentor
    dokumentor = os.path.dirname(os.path.abspath(sys.modules[Konstruct.__module__].__file__))
    dokumentor = os.path.join(dokumentor, "dokumentor.py")

    Utils.run(dokumentor + " exampletest docs/ > tests/jsautotest/autotests.js")

    Gyp.set("nidium_ui_console", "0")
    tests.append((nidium[1] + " ../tests/jsautotest/autotests.nml", nidium[0]))

    Tests.register(tests)

@CommandLine.option("--unit-tests")
def testStudio(unitTests):
    if not unitTests:
        return

    tests = []
    nidium = getNidiumPath()

    # Log unit-tests to stdout
    Gyp.set("nidium_ui_console", "0")

    tests.append((nidium[1] + " ../tests/jsunittest/unittests.nml --frontend", nidium[0]))

    Tests.register(tests)

@CommandLine.option("--debug-opengl", default=False)
def glDebug(debug):
    if not debug:
        return

    Gyp.set("nidium_gl_debug", 1);

@CommandLine.option("--debug")
def debug(debug):
    if not debug:
        return

    glDebug(True)

Build.add(Gyp("gyp/all.gyp"));

if __name__ == '__main__':
    Log.info("Checking for required software...")
    if Platform.system != "Windows":
        if not Utils.findExec("yasm"):
            if not PackageManger.detect():
                Utils.exit("Couldn't find a package manager to install \"yasm\" software. Please install it manually and make sure \"yasm\" executable is in your path before building nidium.")

            if not PackageManger.install("yasm", prompt=True):
                Utils.exit("configure script aborted, couldn't install \"yasm\" dependency. Please install it manually and make sure \"yasm\" executable is in your path.")

    Konstruct.start()
