#!/usr/bin/env python2.7

# Copyright 2016 Nidium Inc. All rights reserved.
# Use of this source code is governed by a MIT license
# that can be found in the LICENSE file.

import sys
import os
import json

from konstructor import Deps
from konstructor import CommandLine
from konstructor import Build
from konstructor import Builder
from konstructor import Platform
from konstructor import Konstruct
from konstructor import Utils
from konstructor import Variables
from konstructor import Tests
from konstructor import PackageManger
from konstructor import Log
from konstructor import ROOT

Gyp = Builder.Gyp

if Platform.system == "Windows":
    Platform.setEnviron("DEPOT_TOOLS_WIN_TOOLCHAIN=0")
    # On windows, nidium use OpenGLES trough ANGLE
    Gyp.set("nidium_opengles2", 1)

Gyp.setArgs("--depth ./ --include=gyp/config.gypi --include=gyp/common.gypi")
Gyp.set("nidium_product_define", "NIDIUM_PRODUCT_FRONTEND")
Gyp.set("nidium_js_disable_window_global", 0)
Gyp.set("nidium_audio", 0)
Gyp.set("nidium_webgl", 1)

DEPEDENCY_REPO = Variables.get("depsRepo")
CONFIGURE_PATH = os.path.dirname(os.path.realpath(__file__))

@Deps.register("portaudio")
def portaudio():
    env = Utils.Env()
    output = "lib/libs/libportaudio.a"

    if Platform.system == "Windows":
        cmake, platform, toolset = Platform.CMake()
        build = [cmake + " -DPA_UNICODE_BUILD=1 -DPA_USE_WASAPI=0 -DPA_USE_WDMKS=0 -DPA_USE_WMME=1",
                Platform.MsBuild("portaudio_static.vcxproj")]
        output = "./Release/portaudio_static_x86.lib"
        patch = []
    else:
        configure = "./configure --disable-shared --enable-static --without-jack --without-asihpi --without-winapi"

        if Konstruct.config("android"):
            # Portaudio doesn't have good support for OpenSLES audio API, use custom build
            location =  Deps.GitRepo("https://github.com/Gundersanne/portaudio_opensles.git", revision="901176c")
            build = ["aclocal", "libtoolize --force", "autoconf",
                     configure + "--with-opensles %s --host=%s" % (Variables.get("targetTriplet"))]
            patch = []
            env.update(Variables.get("androidEnvClang"))
        else:
            location = DEPEDENCY_REPO + "/portaudio.tgz"
            build = [configure]
            patch = [os.path.join(CONFIGURE_PATH, "patch", "portaudio.patch")]

        build.append("make -j1 lib/libportaudio.la src/common/pa_ringbuffer.o")

    return {
        "location": location,
        "patchs": patch,
        "build": build,
        "outputs": [output],
        "env": env
    }

@Deps.register("zita-resampler")
def zitaresampler():
    if Konstruct.config("android"):
        env.update(Variables.get("androidEnvClang"))
    elif Platform.system == "Windows":
        env.append("CXXFLAGS", "-D_USE_MATH_DEFINES -I ../../pthreads4w -D_POSIX_C_SOURCE=200112L")

    return {
        "location": DEPEDENCY_REPO + "/zita-resampler-1.3.0.tar.bz2",
        "patchs": [os.path.join(CONFIGURE_PATH, "patch", "zita-resampler.patch")],
        "chdir": "libs/",
        "build": ["make"],
        "outputs": ["libzita-resampler(.a|.lib)"],
        "env": env
    }

@Deps.register("giflib")
def giflib():
    return {}
# giflib doesn't seems to be required by skia anymore
"""
<<<<<<< HEAD
    location = "http://downloads.sourceforge.net/project/giflib/giflib-4.x/giflib-4.2.3.tar.gz"
    if Platform.system == "Windows":
        Platform.setCompiler("cl", 'cl')
        Platform.setEnviron("LD=link")
        Platform.setEnviron("AR=lib")
        return {
            "location": location,
            "build": ["bash ../configure --disable-shared --enable-static",
                      'sed -i.bak -e "s/AR_FLAGS /AR_FLAGS/" libtool',
                      "make -j1"],
            "chdir": "lib",
            "patchs": [os.path.join(CONFIGURE_PATH, "patch", "giflib_windows.patch")],
            "outputs": ["../lib/.libs/gif.lib"]
        }

    else:
        # skdiff is used during unit-tests and it needs libgif.so.4
        Platform.setEnviron("LD_LIBRARY_PATH=$LD_LIBRARY_PATH:%s/giflib/lib/.libs/" % os.getcwd())
        return {
            "location": location,
            "build": ["./configure", "make"],
            "outputs": ["lib/.libs/libgif.a"]
        }
=======
    # skdiff is used during unit-tests and it needs libgif.so.4
    Platform.setEnviron("LD_LIBRARY_PATH=%s:%s/giflib/lib/.libs/" % (Platform.getEnviron("LD_LIBRARY_PATH", ""), os.getcwd()))

    env = Utils.Env()
    configure = "./configure"

    if Konstruct.config("android"):
        env.update(Variables.get("androidEnvClang"))
        # giflib use some old deprecated flags, Workaround that
        # see https://code.google.com/p/android/issues/detail?id=19710
        env.append("CFLAGS", "-include %s/giflib/lib/android.h" % (os.getcwd()))
        configure = "./configure --host=%s" % (Variables.get("targetTriplet"))

    return {
        "location": "http://downloads.sourceforge.net/project/giflib/giflib-4.x/giflib-4.2.3.tar.gz",
        "build": [configure, "make coverity"],
        "outputs": ["lib/.libs/libgif.a"],
        "patchs": [os.path.join(CONFIGURE_PATH, "patch", "giflib_android.patch")],
        "env": env
    }
"""

@Deps.register("skia")
def skia():
    env = Utils.Env()
    build = [
        "python tools/git-sync-deps"
    ]
    patchs = []
    libSkia = "libskia.a"
    skdiff = "skdiff"
    args = {
        "gn": {
            "extra_cflags_cc": [
                """-DGR_GL_CUSTOM_SETUP_HEADER="%s" """ % ("../../../../../patch/skia_gl_config.h")
            ],
            "is_official_build": True,
            "cc": Platform.getEnviron("CC"),
            "cxx": Platform.getEnviron("CXX")
        }
    }

    if Konstruct.config("android"):
        patchs.append(os.path.join(CONFIGURE_PATH, "patch", "skia_android.patch"))

    if Platform.system == "Windows":
        patchs.append(os.path.join(CONFIGURE_PATH, "patch", "skia_windows.patch"),)
        args["--ide"] = "vs"
        skdiff = "skdiff.exe"
        libSkia = "skia.lib"
    else:
        args["gn"]["extra_cflags_cc"].append("-Wno-unused-function",
                                       "-Wno-array-bounds",
                                       "-Wno-return-local-addr")

        build.append("sed -i.bak '/simpleperf/d' out/Static/build.ninja")

        if Platform.system == "Darwin":
            args["gn"]["extra_cflags_cc"].append("-stdlib=libc++")
            args["gn"]["extra_ldflags"] = ["-stdlib=libc++"]
        elif Konstruct.config("android"):
            androidEnv = Variables.get("androidEnvClang")
            args["gn"]["cc"] = androidEnv.get("CC")
            args["gn"]["cxx"] = androidEnv.get("CXX")

            args["gn"]["ndk"] = Variables.get("androidNdkPath")
            args["gn"]["target_cpu"] = Variables.get("targetArch")

    # Add depot_tools to path needed for skia
    Platform.setEnviron("PATH+=" + os.path.join(Deps.getDir(), "depot_tools"))

    # depot_tools and skia needs python2.7 but use "python" as the default
    # interpreter which could be python3.x on some system. Workaround that
    # by using a custom python wrapper that will redirect to the correct python version
    env.set("PATH", os.path.join(ROOT, "tools") + Utils.Env.SEPARATOR + Platform.getEnviron("PATH", ""))

    skiaArgs = ""
    for k, v in args["gn"].items():
        skiaArgs += " %s=%s" % (k, json.dumps(v))

    gnArgs = ""
    for k, v in args.items():
        if k == "gn":
            continue
        gnArgs += " %s=%s" % (k, json.dumps(v))

    return {
        "location": Deps.GitRepo("https://skia.googlesource.com/skia.git", revision="98829b9"),
        "build": build + [
            "bin\gn.exe gen out/Static/ --args=%s %s" % (json.dumps(skiaArgs), gnArgs),
            "python gn/gn_meta_sln.py" if Platform.system == "Windows" else "",
            "ninja -C out/Static",
        ],
        "patchs": [
            os.path.join(CONFIGURE_PATH, "patch", "skia_gl.patch"),
            os.path.join(CONFIGURE_PATH, "patch", "skia_gr_gl_callback.patch"),
        ] + patchs,
        "outputs": [
            "out/Static/%s" % (libSkia),
            {
                "src": "out/Static/%s" % (skdiff),
                "dst": os.path.join(ROOT, "tests", "jsunittest", "gr", skdiff)
            }
        ],
        "env": env
    }

@Deps.register("libzip")
def libzip():
    env = Utils.Env()

    build = []
    output = "lib/.libs/libzip.a"

    if Platform.system == "Windows":
        output = "./lib/Release/zip.lib"
        cmake, platform, toolset = Platform.CMake()
        build = [cmake + " -DZLIB_LIBRARY=%s/zlib/zlib.lib -DZLIB_INCLUDE_DIR=%s/zlib" % (Deps.getDir(), Deps.getDir()),
                Platform.MsBuild("libzip.sln")]
    else:
        configureArgs = "--disable-shared --with-zlib=%s/zlib/" % (Deps.getDir())
        if Konstruct.config("android"):
            configureArgs = " --host=%s" % (Variables.get("targetTriplet"))
            env.update(Variables.get("androidEnvClang"))

        build = ["./configure %s" % (configureArgs), "make"]

    return {
        "location": "https://nih.at/libzip/libzip-1.2.0.tar.gz",
        "build": build,
        "outputs": [output],
        "env": env
    }

@Deps.register("lss")
def lss():
    if Platform.system == "Windows":
        Utils.exit("The '%s' platform does not need lss" % (Platform.system))
    return {
        "location": Deps.GitRepo("https://chromium.googlesource.com/linux-syscall-support", revision="348bdf8d32b37c8fb2627df7a0a977d1d640e1fc")
    }

def fixAngleThinArchive():
    # By default ANGLE libs are thin archive, and thus, not relocatable
    # which breaks Konstructor way of dealing with archives. We need to
    # update ninja build file, to create "normal" archive
    if Platform.system == "Linux" or Platform.system == "Darwin":
        Utils.run("sed -i.bak \"s/$ar rcsT/$ar rcs/\" out/Release/build.ninja")

@Deps.register("angle")
def angle():
    env = Utils.Env()
    outputs = []
    patchs = []
    buildSteps = [
        "python scripts/bootstrap.py",
        "gclient sync",
    ]

    env.set("PATH", env.get("PATH") + Utils.Env.SEPARATOR +  os.path.join(Deps.getDir(), "depot_tools"))

    if Platform.system == "Windows":
        env.set("GYP_GENERATORS", "msvs")
        env.set("GYP_MSVS_VERSION", "2015")

        buildSteps.append(Platform.MsBuild("build/ANGLE.sln"))

        patchs = [
            os.path.join(CONFIGURE_PATH, "patch", "angle_windows.patch")
        ]

        outPath = "build/Release_x64/lib/"
        outputs = [
            os.path.join(outPath, "preprocessor.lib"),
            os.path.join(outPath, "translator.lib"),
            os.path.join(outPath, "translator_lib.lib"),
            os.path.join(outPath, "angle_common.lib"),
            os.path.join(outPath, "libANGLE.lib"),
            os.path.join(outPath, "libEGL.lib"),
            os.path.join(outPath, "libGLESv2.lib")
        ]
    else:
        buildSteps.append(fixAngleThinArchive)
        buildSteps.append("ninja -C out/Release/ preprocessor translator translator_lib angle_common")

        # Disable some errors for clang 3.5 & 3.7
        env.append("CXXFLAGS", " -Wno-c++11-narrowing -Wno-sign-compare -Wno-error")

        # Angle only build with ninja
        env.set("GYP_GENERATORS", "ninja")

        # Angle build script needs python 2.7
        env.set("PATH", os.path.join(ROOT, "tools") + ":" + env.get("PATH"))

        if Platform.wordSize == 32:
            env.append("CXXFLAGS", " -msse -msse2 -msse3")

        if Platform.system == "Darwin":
            outPath = "out/Release/"
        elif Platform.system == "Linux":
            outPath = "out/Release/obj/src/"

        if Konstruct.config("android"):
            env.update(Variables.get("androidEnvClang"))
            # Regenerate gyp files for android
            buildSteps.insert(2, "python build/gyp_angle -Dis_android=1")

        outputs = [
            os.path.join(outPath, "libpreprocessor.a"),
            os.path.join(outPath, "libtranslator.a"),
            os.path.join(outPath, "libtranslator_lib.a"),
            os.path.join(outPath, "libangle_common.a")
        ]

    return {
        "location": Deps.GitRepo("https://chromium.googlesource.com/angle/angle", branch="chromium/2785"),
        "build": buildSteps,
        "outputs": outputs,
        "env": env,
        "patchs": patchs
    }

@Deps.register("breakpad")
def breakpad():
    return {
        "location": Deps.GitRepo("https://chromium.googlesource.com/breakpad/breakpad", revision="48b9a40539689743bacbe20df01182b0c367c2c0")
    }

@Deps.register("SDL2")
def SDL2():
    build = ["../configure", "make"]
    outputs = ["build/.libs/libSDL2.a"]
    patchs = []
    location = "https://www.libsdl.org/release/SDL2-2.0.5.tar.gz"

    if Konstruct.config("android"):
        # On Android SDL2 is built trough gyp (gyp/third-party/SDL2-android.gyp)
        # because SDL2 build script only works with android NDK and the scripts
        # does not match our toolchain
        return {
            "location": location,
            "patchs": [os.path.join(CONFIGURE_PATH, "patch", "SDL2_android.patch")],
        }

    if Platform.system == "Windows":
        build = [Platform.MsBuild("../VisualC/SDL.sln")]
        patchs = [os.path.join(ROOT, "patch", "SDL2_windows.patch")]
        outPath = "../VisualC/%s/Release/" % ("Win32" if Platform.wordSize == 32 else "x64")
        outputs = [
            outPath + "SDL2.lib",
            {
                "src": outPath + "SDL2.dll",
                "dst": os.path.join(ROOT, "bin", "SDL2.dll")
            }
        ]

    return {
        "location": location,
        "chdir": "build",
        "build": build,
        "outputs": outputs,
        "patchs": patchs
    }

@Deps.register("depot_tools")
def depotTools():
    Deps.Gclient.setExec(os.path.join("depot_tools", "gclient"))

    if Platform.system == "Windows":
        rules = { 'location' : "https://storage.googleapis.com/chrome-infra/depot_tools.zip"}
        if Platform.wordSize == 32:
            rules['build'] = ['cp ../ninja/ninja.exe ../depot_tools/' ]
    else:
        rules = {'location' : Deps.GitRepo("https://chromium.googlesource.com/chromium/tools/depot_tools.git", revision="8bf327c")}

    return rules

@Deps.register("basekit")
def basekit():
    env = Utils.Env()

    build = ["make"]
    patchs = [os.path.join(CONFIGURE_PATH, "patch", "basekit.patch")]


    if Platform.system == "Windows":
        # XXX : WIP
        env.set("SYS", "Windows")
        env.set("INSTALL_PREFIX", os.path.join(ROOT, "third-party", "basekit", "install"))
        patchs = [os.path.join(root, "patch", "basekit_windows.patch")]
        build = ['mkdir "_build/objs" "_build/lib"||true',
                 "make -j1  _build/lib/libbasekit.a PLATFORM=%s" % (["x86","x64"][Platform.wordSize == 64])]
    elif Konstruct.config("android"):
        env.update(Variables.get("androidEnvClang"))
        NdkPath = Variables.get("androidNdkPath")
        NDKAPIVersion = Variables.get("androidNDKAPIVersion")
        arch = "arm"
        env.append("CFLAGS", "-I %s/platforms/android-%d/arch-%s/usr/include/" % (NdkPath, NDKAPIVersion, arch))

    return {
        "location": Deps.GitRepo("https://github.com/stevedekorte/basekit.git", revision="a3e54ba83b85f530dc9442a33d2779240ed96189"),
        "build": build,
        "patchs": patchs,
        "outputs": ["_build/lib/libbasekit(.a|.lib)"],
        "env": env
    }

@Deps.register("libcoroutine")
def libcoro():
    env = Utils.Env()
    build = ["make"]
    patchs = [os.path.join(CONFIGURE_PATH, "patch", "libcoroutine.patch")]

    if Platform.system == "Windows":
        # XXX : WIP
        env.set('SYS=Windows')
        build = ['mkdir "_build/objs" "_build/lib"||true', "make -j1 _build/objs _build/lib/liblibcoroutine.a"]
        patchs = [os.path.join(CONFIGURE_PATH, "patch", "libcoroutine_windows.patch")]
    elif Konstruct.config("android"):
        env.update(Variables.get("androidEnvClang"))

    return {
        "location": Deps.GitRepo("https://github.com/stevedekorte/coroutine.git", revision="b0bf11d8a0ec70bc0f1f5043513d334e1eff15fc"),
        "patchs": patchs,
        "build": build,
        "outputs": [["_build/lib/liblibcoroutine(.a|.lib)", "libcoroutine\\1"]],
        "env": env
    }

@Deps.register("rapidxml")
def rapidxml():
    return {
        "location": "http://downloads.sourceforge.net/project/rapidxml/rapidxml/rapidxml%201.13/rapidxml-1.13.zip",
        "patchs": [  os.path.join(CONFIGURE_PATH, "patch", "rapidxml.patch")],
    }

@Deps.register("ffmpeg")
def ffmpeg():
    env = Utils.Env()
    configureArgs = ''
    makeOpt = ""
    configure = "./configure"

    if Platform.system == "Windows":
        # FFmpeg 3.0.7 has a problem on windows where an pathname gets in the $(OBJ) list, lib.exe is more sensitive than ar
        # TODO : Check if this is this still the case with the recent ffmpeg update ?
        configure = "bash configure"
        configureArgs += " --toolchain=msvc --extra-cxxflags=\"-MD\" --extra-cflags=\"-MD\" --extra-ldflags=\"/nodefaultlib:libcmt.lib\" --disable-swscale"
        # patchs = [  os.path.join(CONFIGURE_PATH, "patch", "ffmpeg_windows.patch")]
        make_opt += " -j1"
    elif Konstruct.config("android"):
        env.update(Variables.get("androidEnvClang"))
        configureArgs += " --enable-cross-compile"
        configureArgs += " --cross-prefix=%s" % ("arm-linux-androideabi-") #(Variables.get("targetTriplet"))
        configureArgs += " --target-os=linux"
        configureArgs += " --arch=arm"
        configureArgs += " --cpu=cortex-a8"
        configureArgs += " --enable-yasm"
        configureArgs += " --enable-runtime-cpudetect"
        configureArgs += " --enable-pic"
        configureArgs += " --disable-asm"
        configureArgs += " --cc=%s" % (Variables.get("androidEnvClang").get("CC"))
        configureArgs += " --enable-decoder=h264_mediacodec --enable-mediacodec --enable-hwaccel=h264_mediacodec --enable-jni"
        env.set("PATH", os.path.join(ROOT, "tools") + ":" + Platform.getEnviron("PATH", ""))

    return {
        "location": Deps.GitRepo("git://git.ffmpeg.org/ffmpeg.git", tag="n3.3"),
        "build":
        [
            "%s %s --disable-shared \
            --disable-vaapi --disable-avdevice --disable-postproc --disable-avfilter --disable-ffserver --disable-lzma --disable-bzlib --disable-vdpau\
            --enable-decoder=ac3,aac,mp3,vorbis,pcm_s16be_planar,pcm_s16le,pcm_s16le_planar,pcm_s24be,pcm_s24daud,pcm_s24le,pcm_s24le_planar,pcm_s32be,pcm_s32le,pcm_s32le_planar,pcm_s8,pcm_s8_planar,pcm_u16be,pcm_u16le,pcm_u24be,pcm_u24le,pcm_u32be,pcm_u32le,pcm_u8,h264,mpeg4,mpeg2video,wmv1,wmv2,wmv3,wmv3_crystalhd,wmv3image,wmalossless,wmapro,wmav1,wmav2,wmavoice,vc1,vc1_crystalhd,vc1image\
            --enable-parser=vorbis,mpegaudio,mpegvideo,mpeg4video,h264,vp8,aac,vc1\
            --enable-demuxer=matroska,mp3,ogg,vorbis,pcm_alaw,pcm_f32be,pcm_f32le,pcm_f64be,pcm_f64le,pcm_mulaw,pcm_s16be,pcm_s16le,pcm_s24be,pcm_s24le,pcm_s32be,pcm_s32le,pcm_s8,pcm_u16be,pcm_u16le,pcm_u24be,pcm_u24le,pcm_u32be,pcm_u32le,pcm_u8,h264,mpegvideo,aac,mov,avi,wav,asf",
            "make V=1" % (configure, configureArgs)
        ],
        "outputs":
        [
            "libavcodec/libavcodec(.a|.lib)",
            "libswresample/libswresample(.a|.lib)",
            "libavutil/libavutil(.a|.lib)",
            "libavformat/libavformat(.a|.lib)",
            "libswscale/libswscale(.a|.lib)"
        ],
        "env": env
    }

@Deps.register("libnotify")
def libnotify():
    return {
        "location": DEPEDENCY_REPO + "/libnotify-0.7.6.tar.gz",
        "build": ["./configure", "make"],
        "outputs": ["libnotify/.libs/libnotify.a"]
    }


def getNidiumPath():
    nidium = ""
    if Platform.system == "Linux":
        return ("bin/", "./nidium")
    elif Platform.system == "Darwin":
        return ("bin/", "./nidium.app/Contents/MacOS/nidium")
    else:
        raise Exception("TODO : Unsupported platform, cannot find nidum executable")

def addEmbed():
    # Build dir2nvfs
    if not os.path.exists("tools/dir2nvfs"):
        Gyp("gyp/tools.gyp", defines={"nidium_js_disable_window_global": 1,
                                      "nidium_product_define": "DIR2NVFS"}).run("dir2nvfs")

    # Generate the embed file with dir2nvfs
    Gyp("gyp/actions.gyp").run("generate-embed", parallel=False)

    # Now that the embed are packaged
    # we can add add nidium_package_embed flag
    Gyp.set("nidium_package_embed", 1)

@CommandLine.option("--embed", default=False)
def embed(embed):
    if embed:
        @Konstruct.hook("preBuild")
        def preBuildAddEmbed():
            addEmbed()

@CommandLine.option("--auto-tests", default=False)
def autoTestStudio(autoTests):
    if not autoTests:
        return

    tests = []
    nidium = getNidiumPath()

    # Find Konstrutor path, to run Dokumentor
    dokumentor = os.path.dirname(os.path.abspath(sys.modules[Konstruct.__module__].__file__))
    dokumentor = os.path.join(dokumentor, "dokumentor.py")

    Utils.run(dokumentor + " exampletest docs/ > tests/jsautotest/autotests.js")

    Gyp.set("nidium_ui_console", "0")
    tests.append((nidium[1] + " ../tests/jsautotest/autotests.nml", nidium[0]))

    Tests.register(tests)

@CommandLine.option("--unit-tests")
def testStudio(unitTests):
    if not unitTests:
        return

    tests = []
    nidium = getNidiumPath()

    # Log unit-tests to stdout
    Gyp.set("nidium_ui_console", "0")

    tests.append((nidium[1] + " ../tests/jsunittest/unittests.nml --frontend", nidium[0]))

    Tests.register(tests)

@CommandLine.option("--bundle", default=False)
def frontendAndroidBundle(bundle):
    if not bundle:
        return

    Gyp.set("nidium_android_bundle", 1)

@CommandLine.option("--android")
def frontendAndroid(android):
    if not android:
        return

    Gyp.set("nidium_opengles2", 1)

    @Konstruct.hook("postBuild")
    def postBuildAndroid(success):
        import shutil
        if not success:
            return

        cpu = Variables.get("targetCpu")
        libDir = "armeabi"
        if "v7" in cpu:
            libDir = "armeabi-v7a"

        outDir = "src/Frontend/app/android/app/src/main/jniLibs/%s/" % libDir

        Log.info("Copying libnidium_android.so to %s" % outDir)

        Utils.mkdir(outDir)
        shutil.copy("build/out/%s/lib/libnidium_android.so" % Gyp.getConfiguration(), outDir)

        with Utils.Chdir("src/Frontend/app/android/"):
            env = Utils.Env();
            env.set("ANDROID_HOME", os.path.join(ROOT, "third-party", "android-sdk"))

            Log.info("Building android app")
            if Gyp.get("nidium_android_bundle"):
                Utils.run("./gradlew assembleRelease installRelease", env=env)
            else:
                #Utils.run("./gradlew assemble%s" % Gyp.getConfiguration(), env=env)
                Utils.run("./gradlew assembleDebug", env=env)

                Log.info("Installing android app")
                #Utils.run("./gradlew install%s" % Gyp.getConfiguration(), env=env)
                Utils.run("./gradlew installDebug", env=env)

@CommandLine.option("--debug-opengl", default=False)
def glDebug(debug):
    if not debug:
        return

    Gyp.set("nidium_gl_debug", 1);

@CommandLine.option("--debug")
def debug(debug):
    if not debug:
        return

    glDebug(True)

Build.add(Gyp("gyp/all.gyp"));

@Konstruct.hook("start")
def setDependencies():
    Deps.append(
        "depot_tools",
        "giflib",
        "skia",
        "libzip",
        "SDL2",
        "rapidxml",
        "angle"
        #"breakpad",
    )

    if Platform.system != "Windows":
        # linux, OSX, android
        Deps.append("lss")

    if Gyp.get("nidium_audio") == 1:
        Deps.append(
            "zita-resampler",
            "basekit",
            "libcoroutine",
            "portaudio",
            "ffmpeg"
            )

    if not Konstruct.config("android") and Platform.system == "Linux":
        Deps.append("libnotify")

    Deps.append(Deps.Konstruct("libnidiumcore", "configure_libnidiumcore"))

if __name__ == '__main__':
    Log.info("Checking for required software...")
    if Platform.system != "Windows":
        if not Utils.findExec("yasm"):
            if not PackageManger.detect():
                Utils.exit("Couldn't find a package manager to install \"yasm\" software. Please install it manually and make sure \"yasm\" executable is in your path before building nidium.")

            if not PackageManger.install("yasm", prompt=True):
                Utils.exit("configure script aborted, couldn't install \"yasm\" dependency. Please install it manually and make sure \"yasm\" executable is in your path.")

    Konstruct.start()
